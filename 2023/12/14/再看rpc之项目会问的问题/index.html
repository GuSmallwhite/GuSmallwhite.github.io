<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="再看rpc之项目会问的问题, 说的">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>再看rpc之项目会问的问题 | 说的</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>




<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">说的</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">说的</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">再看rpc之项目会问的问题</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/rpc/">
                                <span class="chip bg-color">rpc</span>
                            </a>
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95/" class="post-category">
                                面向面试
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-14
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了面对面试官的穷追猛打，我先把别人面试遇到的问题先放在这</p>
<p>然后我们按不同的人遇到的，进行分类</p>
<h2 id="来自牛客高启盛-pdd"><a href="#来自牛客高启盛-pdd" class="headerlink" title="来自牛客高启盛-pdd"></a>来自牛客高启盛-pdd</h2><h3 id="描述一下服务注册到注册中心和服务下线的一个具体流程"><a href="#描述一下服务注册到注册中心和服务下线的一个具体流程" class="headerlink" title="描述一下服务注册到注册中心和服务下线的一个具体流程"></a>描述一下服务注册到注册中心和服务下线的一个具体流程</h3><p>答：</p>
<p>服务注册是使用bean扫描的方式进行自动注册，我自定义了两个注解，一个是服务提供者，一个是服务消费者的注册，通过**<code>postProcessBeforeInitialization</code>**方法，在方法内实现判断当前bean是否被@RpcService注解标记，如果有就将其注册到zk上。</p>
<p>通过**<code>postProcessAfterInitialization</code>**方法，在方法内判断当前bean是否被@RpcReference标记，如果有就构建代理对象并设置到对应的字段当中，实现让他能够以类似本地调用的行为去进行远程调用。</p>
<p>当服务器关闭时，我通过设置 的<code>CustomShutdownHook</code>关闭钩子，清除所有注册的服务以及关闭所有创建的线程池。</p>
<p>在服务器运行过程当中，使用监听器，监听zk节点的变化，并进行更新</p>
<h3 id="如果zk中的服务节点退出了，服务还能访问吗，怎么做"><a href="#如果zk中的服务节点退出了，服务还能访问吗，怎么做" class="headerlink" title="如果zk中的服务节点退出了，服务还能访问吗，怎么做"></a>如果zk中的服务节点退出了，服务还能访问吗，怎么做</h3><p>可以，项目当中使用了一致性哈希负载均衡算法，当一个服务节点退出了之后，首先监听器会得到这个事件，然后去进行对应的更新</p>
<p>然后当服务节点退出了之后，在使用一致性哈希算法进行选择服务地址的时候，会发现当前选择器的哈希值和服务对应的哈希值不同，那么将会重新构建选择器，并且更新缓存，从而将原本节点的任务分配给他的下一个节点</p>
<p>为了解决一个节点无法承受很多请求量的雪崩问题，我们还设置了虚拟节点，将一个物理结点拆分成多个虚拟节点，解决资源不平衡问题</p>
<h3 id="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信？"><a href="#如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信？" class="headerlink" title="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信？"></a>如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信？</h3><p>答：</p>
<p>可以看这一篇文章，我这项目里没解决这个问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan/article/details/121451672">RPC：优雅关闭，如何避免服务停机带来的业务损失_rpcbind服务关闭影响-CSDN博客</a></p>
<p>是不是可以在重启机器之前，<strong>先通过“某种方式”把要下线的机器从调用方维护的“健康列表”中删除就可以了，这样负载均衡机制就选不中这个节点的</strong>？</p>
<ul>
<li><p>因为服务提供方已经开始进入了关闭流程，那么很多对象就可能已经销毁了，关闭后再收到的请求按照正常业务请求来处理，肯定是没法保证能处理的。所以，我们可以<strong>在关闭的时候，设置一个请求“挡板”，挡板的作用就是告诉调用方，我已经开始进入关闭流程了，不能再处理你的这个请求了</strong>。</p>
</li>
<li><p>一个生活中的例子就是银行在交接班或者有其他要事情处理的时候，银行柜台工作人员会拿出一个纸板，放在窗口前，上面写到“该窗口已关闭”。在该窗口排队的人虽然有一万个不愿意，也只能换到其它窗口办理业务，因为柜台工作人员会把当前正在办理的业务处理完后正式关闭窗口。</p>
</li>
<li><p>基于这个思路，我们可以这样处理：</p>
<ul>
<li><strong>当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方</strong>（比如shutdownException）。</li>
<li>这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”</li>
<li><strong>然后调用方收到这个异常响应后，RPC框架把这个节点从健康列表中拿出，并把请求自动重试到其他节点</strong>，因为这个请求是没有被服务提供方处理过，所以可以安全的重试到其他节点，这样就可以实现对业务无损。</li>
</ul>
</li>
<li><p>但是如果只是靠等待被动，就会让这个关闭流程整体有点漫长。因为有的调用方那个时刻没有业务请求，就不能及时的通知调用方了，所以我们可以加上主动通知流程，这样既可以保证实时性，也可以避免通知失败的情况。</p>
</li>
</ul>
<p>问题：<strong>要怎么捕获到关闭事件呢</strong>？</p>
<ul>
<li>可以通过捕获操作系统的进程信号来获取</li>
<li>在RPC启动的时候，我们提前注册关闭钩子，并在里面添加两个处理程序，一个负责关闭标识，一个负责安全关闭服务对象:<ul>
<li><strong>服务对象在关闭的时候会通知调用方下线节点</strong>。</li>
<li>同时需要我们在调用链里面加上挡板处理器，<strong>当新的请求来的时候，会判断关闭表示，如果正在关闭，则抛出异常</strong>。</li>
</ul>
</li>
</ul>
<p>问题：关闭过程中已经在处理的请求会不会被影响呢？</p>
<ul>
<li>如果进程结束过快会造成这些请求还没有来得及应答，同时调用方也会抛出异常。 为了尽可能的完成正在处理的请求，首先我们要把这些请求标识出来。</li>
<li>这就好比日常生活中，我们经常看见停车场指示牌上提示还有多少剩余车位，这个是如何做到的呢？如果仔细观察一下，你就会发现它是每进入一辆车，剩余车位就减一，每出来一辆车，剩余车位就加一。</li>
<li>我们也可以利用这个原理<strong>在服务对象加上引用计数器，每开始处理请求之前加一，完成请求处理减一，通过该计数器我们就可以快速判断是否有正在处理的请求</strong>。</li>
<li><strong>服务对象在关闭过程中，会拒绝新的请求，同时根据引用计数器等待正在处理的请求全部结束之后才会真正关闭</strong>。</li>
<li>但考虑到有些业务请求可能会处理时间长，或者存在被挂住的情况，为了避免一直等待造成应用无法正常退出，我们可以<strong>在整个shutdownHook里面，加上超时时间控制，当超过了指定时间还没结束，就强制退出应用</strong>。超时时间建议10s，基本可以确保请求都处理完了。</li>
</ul>
<h2 id="来自牛客高启盛-字节一面"><a href="#来自牛客高启盛-字节一面" class="headerlink" title="来自牛客高启盛-字节一面"></a>来自牛客高启盛-字节一面</h2><h3 id="介绍一下-Netty、Socket、Http-三种通信方式的区别"><a href="#介绍一下-Netty、Socket、Http-三种通信方式的区别" class="headerlink" title="介绍一下 Netty、Socket、Http 三种通信方式的区别"></a>介绍一下 Netty、Socket、Http 三种通信方式的区别</h3><p>答：</p>
<p>Socket是基于传输层的协议，Socket 编程提供了底层的灵活性，但需要程序员自己处理协议的细节。适用于需要直接操作网络层的场景，例如实现自定义的网络协议、P2P 网络通信等</p>
<p>Http是建立在tcp之上的应用层的协议，定义了客户端和服务端请求和响应的格式</p>
<p>而Netty是提供了异步事件驱动的开源网络框架，可以支持多种协议，包含http，适用于构建高性能的网络应用</p>
<h3 id="如何用Socket去实现Netty的线程模型"><a href="#如何用Socket去实现Netty的线程模型" class="headerlink" title="如何用Socket去实现Netty的线程模型"></a>如何用Socket去实现Netty的线程模型</h3><p>netty线程模型爷还没看，等会看</p>
<h3 id="自定义协议和编解码的具体做法"><a href="#自定义协议和编解码的具体做法" class="headerlink" title="自定义协议和编解码的具体做法"></a>自定义协议和编解码的具体做法</h3><p>本项目使用了自定义传输协议;</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">*</span>   <span class="token number">0</span>     <span class="token number">1</span>     <span class="token number">2</span>     <span class="token number">3</span>     <span class="token number">4</span>        <span class="token number">5</span>     <span class="token number">6</span>     <span class="token number">7</span>     <span class="token number">8</span>         <span class="token number">9</span>          <span class="token number">10</span>      <span class="token number">11</span>     <span class="token number">12</span>  <span class="token number">13</span>  <span class="token number">14</span>   <span class="token number">15</span> <span class="token number">16</span>
<span class="token operator">*</span>   <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">*</span>   <span class="token operator">|</span>   magic   code        <span class="token operator">|</span>version <span class="token operator">|</span> full length         <span class="token operator">|</span> messageType<span class="token operator">|</span> codec<span class="token operator">|</span>compress<span class="token operator">|</span>    <span class="token class-name">RequestId</span>       <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                                                                                       <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                         body                                                          <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                                                                                       <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                        <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">*</span> <span class="token number">4</span>B  magic code（魔法数）   <span class="token number">1</span>B version（版本）   <span class="token number">4</span>B full length（消息长度）    <span class="token number">1</span>B messageType（消息类型）
<span class="token operator">*</span> <span class="token number">1</span>B compress（压缩类型） <span class="token number">1</span>B codec（序列化类型）    <span class="token number">4</span>B  requestId（请求的<span class="token class-name">Id</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先包含4个字节的魔数，用于筛选消息是否符合自定义协议</p>
<p>然后是1字节的版本号</p>
<p>然后是4字节的消息长度位，用来表示消息长度</p>
<p>然后是1字节的消息类型，表示是请求消息，响应消息还是心跳消息</p>
<p>然后是一字节的序列化类型，表示采用什么序列化协议</p>
<p>然后是一字节的压缩类型，表示使用了什么压缩算法</p>
<p>然后是4字节的请求id，用于判断请求和响应是否对应</p>
<p>最后是请求体，也就是内容</p>
<p>本项目采用了kryo进行序列化，我自定义了编码器和解码器，编码就是将消息先按照协议写入魔数等等，然后再将消息体的内容进行序列化，再压缩，最后存入bytebuf中</p>
<p>解码就是将消息从bytebuf中读取，先按照协议检查魔数等是否对应，如果对应则进行解压缩和反序列化</p>
<h3 id="五种序列化算法的体积的比较"><a href="#五种序列化算法的体积的比较" class="headerlink" title="五种序列化算法的体积的比较"></a>五种序列化算法的体积的比较</h3><p>我也不知道面试官问的哪些，我就默认是这五种了：</p>
<ul>
<li><p><strong>JDK原生</strong>：作为一个成熟的编程语言，JDK自带了序列化方法。只需要类实现了<code>Serializable</code>接口，就可以通过<code>ObjectOutputStream</code>类将对象变成byte[]字节数组。</p>
<p>JDK 序列化会把对象类的描述信息和所有的属性以及继承的元数据都序列化为字节流，所以会导致<strong>生成的字节流相对比较大</strong></p>
</li>
<li><p><strong>ProtoBuf</strong>:谷歌推出的，是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。序列化后<strong>体积小</strong>，一般用于对传输性能有较高要求的系统。</p>
</li>
<li><p><strong>Hessian</strong>：是一个轻量级的二进制 web service 协议，主要用于传输二进制数据，<strong>相对于 JDK 原生序列化，Hessian序列化之后体积更小。但是比Protobuf大。</strong></p>
</li>
<li><p><strong>Kryo</strong>： 号称 Java 最快的序列化框架。Kryo 在序列化速度上很有优势，底层依赖于字节码生成机制。由于只能限定在 JVM 语言上，所以 Kryo 不支持跨语言使用。</p>
</li>
<li><p><strong>JSON</strong>： JSON 序列化方式生成的是一串有规则的字符串，在可读性上要优于上面几种方式，但是在体积上就没什么优势了</p>
</li>
</ul>
<p>从二进制流大小来讲：JSON 序列化 &gt; Java 序列化 &gt; Hessian2 序列化 &gt; Kryo 序列化 </p>
<h3 id="为什么-Kryo-的体积小？（原理）"><a href="#为什么-Kryo-的体积小？（原理）" class="headerlink" title="为什么 Kryo 的体积小？（原理）"></a>为什么 Kryo 的体积小？（原理）</h3><p>有一说一找遍全网没找到答案</p>
<p>Kryo使用二进制格式进行序列化，而不是类似于JSON或XML这样的文本格式。二进制格式通常更加紧凑。 Kryo在序列化的过程中不保存类型信息或字段名，而是使用索引或标签，这减少了序列化数据中的冗余信息。</p>
<p>Kryo为了提供性能和减小序列化结果体积，提供注册的序列化对象类的方式。</p>
<p>在注册时，会为该序列化类生成int ID，后续在序列化时使用int ID唯一标识该类型。</p>
<p>注册的方式如下：</p>
<p>或者可以明确指定注册类的int ID，但是该ID必须大于等于0。如果不提供，内部将会使用int++的方式维护一个有序的int ID生成。</p>
<p>hessian使用了固定长度存储int和long，而kryo则使用的变长，实际中，很大的数据不会经常出现</p>
<p>hessian将序列化的字段长度写入来确定一段field的结束，而kryo对于String将其最后一位byte+x70用于标识结束</p>
<h3 id="使用这种方式进行序列化反序列化的问题是什么"><a href="#使用这种方式进行序列化反序列化的问题是什么" class="headerlink" title="使用这种方式进行序列化反序列化的问题是什么"></a>使用这种方式进行序列化反序列化的问题是什么</h3><p>就相当于是问kryo的缺点呗</p>
<ol>
<li><p><strong>不支持包含无参构造器类的反序列化</strong> ，尝试反序列化一个不包含无参构造器的类将会得到以下的异常</p>
</li>
<li><p>Kryo 是线程不安全的，意味着每当需要序列化和反序列化时都需要实例化一次，或者借助 ThreadLocal 来维护以保证其线程安全。</p>
</li>
<li><p><strong>缓存大小</strong>：Kryo 使用缓存来存储已经序列化或反序列化过的对象，默认情况下缓存大小为 4096。如果需要处理大量的对象，请适当增加缓存大小以提高性能。</p>
</li>
</ol>
<h3 id="几种序列化算法时间上的对比"><a href="#几种序列化算法时间上的对比" class="headerlink" title="几种序列化算法时间上的对比"></a>几种序列化算法时间上的对比</h3><p>从序列化耗时而言来讲：GSON 序列化 &gt; Java 序列化 &gt; Kryo 序列化 &gt; Hessian2 序列化 &gt; Kryo 序列化注册模式</p>
<p>从反序列化耗时而言来讲：GSON 序列化 &gt; Java 序列化 &gt; Hessian2 序列化 &gt; Kryo 序列化注册模式 &gt; Kryo 序列化</p>
<p>从总耗时而言：Kryo 序列化注册模式耗时最短</p>
<h3 id="Netty通信的心跳机制如何实现的"><a href="#Netty通信的心跳机制如何实现的" class="headerlink" title="Netty通信的心跳机制如何实现的"></a>Netty通信的心跳机制如何实现的</h3><p>在客户端channel的pipeline里添加IdleStateHandler，用于处理空闲状态，本项目设置的是如果5秒内没有写操作，也就是服务端没有向客户端发送内容，那么就触发写空闲事件</p>
<p>在触发写空闲事件后，在 userEventTriggered方法中，我们获取到的IdleStateEvent就会是WRITER_IDLE表示写空闲，那么客户端会发送心跳请求，维持和服务端的链接 </p>
<p>同样的再服务端channel也添加这样的handler，但是关注的是读事件，如果30秒没有从客户端读取，那么就发送心跳请求，维持和客户端的链接</p>
<h3 id="使用zk做服务注册和发现中心，具体实现流程"><a href="#使用zk做服务注册和发现中心，具体实现流程" class="headerlink" title="使用zk做服务注册和发现中心，具体实现流程"></a>使用zk做服务注册和发现中心，具体实现流程</h3><p>这个和pdd的问法一样啊</p>
<h3 id="zk的一致性算法（ZAB原理"><a href="#zk的一致性算法（ZAB原理" class="headerlink" title="zk的一致性算法（ZAB原理"></a>zk的一致性算法（ZAB原理</h3><p>你以为他要问的是你选择的一致性哈希？不是，他问的是zab !是zookeeper自己选择的那个算法！</p>
<p><a target="_blank" rel="noopener" href="https://houbb.github.io/2018/10/30/zab">ZAB-一致性算法 | Echo Blog (houbb.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/70472178edd0a86fbf4a42785">面试官zookeeper 是如何实现一致性的？我大意了，让我回去等通知_Java_InfoQ写作社区</a></p>
<p>有一说一有点复杂，后面在总结</p>
<p>面试的时候你要说：讲了ZAB是paxos的改版，Mysql是paxos、redis sentinel是raft、zookeeper是ZAB、ZAB的具体实现）</p>
<h3 id="针对游戏客户端登录服务器的问题，每个客户端进行登录都要先去服务端申请id，当出现大量客户同时登录如何处理，当登录失败如何处理，如何提高id申请的可用性解决方案"><a href="#针对游戏客户端登录服务器的问题，每个客户端进行登录都要先去服务端申请id，当出现大量客户同时登录如何处理，当登录失败如何处理，如何提高id申请的可用性解决方案" class="headerlink" title="针对游戏客户端登录服务器的问题，每个客户端进行登录都要先去服务端申请id，当出现大量客户同时登录如何处理，当登录失败如何处理，如何提高id申请的可用性解决方案"></a>针对游戏客户端登录服务器的问题，每个客户端进行登录都要先去服务端申请id，当出现大量客户同时登录如何处理，当登录失败如何处理，如何提高id申请的可用性解决方案</h3><p>我草这什么玩意，一个一个看吧</p>
<p><strong>并发登录请求处理</strong></p>
<ul>
<li><strong>使用分布式锁：</strong> 在申请ID的过程中，可以使用分布式锁来保证同一时间只有一个客户端能够成功申请ID。这可以防止多个客户端同时请求导致的问题。</li>
<li><strong>限流：</strong> 可以限制每秒允许的登录请求次数，以减轻服务器的压力。可以使用令牌桶算法或漏桶算法来实现。</li>
</ul>
<p><strong>登录失败处理：</strong></p>
<ul>
<li><strong>错误码返回：</strong> 在登录失败时，服务器可以返回特定的错误码，客户端根据错误码进行相应的处理，例如重新尝试登录或者展示错误提示。</li>
<li><strong>日志记录：</strong> 记录登录失败的详细信息，便于后续排查问题。</li>
</ul>
<p><strong>提高ID申请的可用性：</strong></p>
<ul>
<li><strong>ID生成器优化：</strong> 使用高效的ID生成器，确保在高并发情况下仍能够迅速生成唯一ID。可以考虑使用<strong>Snowflake算法</strong><a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-domain-id-snowflake.html">snowflake</a>等。</li>
<li><strong>缓存ID：</strong> 在一定时间内，可以将已经生成的ID缓存起来，避免频繁地生成新的ID。这在高并发登录场景下可以提高性能。</li>
</ul>
<h3 id="对RPC压力测试的具体实现过程"><a href="#对RPC压力测试的具体实现过程" class="headerlink" title="对RPC压力测试的具体实现过程"></a>对RPC压力测试的具体实现过程</h3><p>这个压力测试我还没做，他妈的</p>
<h3 id="假设有3台服务器，性能比为1：2：3，设计一个负载均衡算法能合理进行负载均衡"><a href="#假设有3台服务器，性能比为1：2：3，设计一个负载均衡算法能合理进行负载均衡" class="headerlink" title="假设有3台服务器，性能比为1：2：3，设计一个负载均衡算法能合理进行负载均衡"></a>假设有3台服务器，性能比为1：2：3，设计一个负载均衡算法能合理进行负载均衡</h3><p>我们可以使用加权轮询算法</p>
<p>我们按照性能给3个服务器分别设置权重为10,20,30总和权重为60，这样每个服务器就在0-60里占有一部分空间，然后我们取0-60的随机数，落入哪个区间就分配给哪个服务器，这样只要服务次数够多，就会无线接近权重分配.缺点是如果一个服务器权重过大，那么一段时间就会有大部分请求落入其中，造成不平衡。</p>
<p>在此基础上，平滑加权算法来了.</p>
<p>每个服务器不仅有不变的配置权重，还有当前权重，每次请求到达时，所有节点就在当前权重基础上加一个配置权重值那就是60，然后选择当前权重最大的节点，当处理完毕后，处理的那个节点权重值需要减去总“配置权重值”，在这里也就是60，然后重复这个过程,nginx就是这个算法</p>
<h3 id="针对每个接口，业务执行的时间在某一个范围之内随机跳动，你如何去设计负载均衡算法"><a href="#针对每个接口，业务执行的时间在某一个范围之内随机跳动，你如何去设计负载均衡算法" class="headerlink" title="针对每个接口，业务执行的时间在某一个范围之内随机跳动，你如何去设计负载均衡算法"></a>针对每个接口，业务执行的时间在某一个范围之内随机跳动，你如何去设计负载均衡算法</h3><p>我超，不会</p>
<h2 id="来自牛客高启盛-携程面试"><a href="#来自牛客高启盛-携程面试" class="headerlink" title="来自牛客高启盛-携程面试"></a>来自牛客高启盛-携程面试</h2><h3 id="客户端进行远程调用的时候是每一次都要去访问注册中心进行服务发现吗"><a href="#客户端进行远程调用的时候是每一次都要去访问注册中心进行服务发现吗" class="headerlink" title="客户端进行远程调用的时候是每一次都要去访问注册中心进行服务发现吗"></a>客户端进行远程调用的时候是每一次都要去访问注册中心进行服务发现吗</h3><p>并不是实际访问了注册中心，我设计了SERVICE_ADDRESS_MAP，缓存了每个服务对应的子节点列表，当客户端进行远程调用的时候，会先去这个缓存里寻找，通过一致性哈希算法选择一个节点。</p>
<h3 id="获取结果是同步还是异步的"><a href="#获取结果是同步还是异步的" class="headerlink" title="获取结果是同步还是异步的"></a>获取结果是同步还是异步的</h3><p>目前是异步的，我使用了CompletableFuture对象来包装RpcResponse,然后将他存入一个名为unprocessedRequests的map里，一开始future里并没有内容，等客户端调用complete方法后，才会在方法内执行future.complete，这才获得了具体的rpc返回响应</p>
<h3 id="客户端是否知道什么时候结果已经返回了"><a href="#客户端是否知道什么时候结果已经返回了" class="headerlink" title="客户端是否知道什么时候结果已经返回了"></a>客户端是否知道什么时候结果已经返回了</h3><p>当服务器处理完请求并返回响应时，响应中包含了相同的<code>requestId</code>。Netty RPC客户端的处理程序会从响应中取出<code>requestId</code>，然后根据<code>requestId</code>找到对应的<code>CompletableFuture</code>，将响应设置到<code>CompletableFuture</code>中</p>
<p>有一说一 还是没有回答这个问题</p>
<h2 id="来自牛客高启盛-美团一面"><a href="#来自牛客高启盛-美团一面" class="headerlink" title="来自牛客高启盛-美团一面"></a>来自牛客高启盛-美团一面</h2><h3 id="Netty的线程模型，主从线程模型"><a href="#Netty的线程模型，主从线程模型" class="headerlink" title="Netty的线程模型，主从线程模型"></a>Netty的线程模型，主从线程模型</h3><p><a target="_blank" rel="noopener" href="https://klose911.github.io/html/netty/thread.html#org927b7aa">Netty 多线程模型 (klose911.github.io)</a></p>
<p>客户端线程模型如下：</p>
<ol>
<li>由用户线程负责初始化客户端资源，发起连接操作</li>
<li>如果连接成功，将SocketChannel注册到IO线程组的NioEventLoop线程中，监听读操作位</li>
<li>如果没有立即连接成功，将SocketChannel注册到IO线程组的NioEventLoop线程中，监听连接操作位</li>
<li>连接成功之后，修改监听位为READ，但是不需要切换线程</li>
</ol>
<p>然后看这个文章总结吧，要面试的时候说呢，就这么说：</p>
<p>主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I&#x2F;O 的读写等操作，从而保证 mainReactor 只负责接入认证、握手等操作；</p>
<h3 id="了解Netty当中的时间轮吗"><a href="#了解Netty当中的时间轮吗" class="headerlink" title="了解Netty当中的时间轮吗"></a>了解Netty当中的时间轮吗</h3><p>上面那个文章也提到了</p>
<p>[21 技巧篇：延迟任务处理神器之时间轮 HashedWheelTimer (lianglianglee.com)](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty">https://learn.lianglianglee.com/专栏/Netty</a> 核心原理剖析与 RPC 实践-完&#x2F;21  技巧篇：延迟任务处理神器之时间轮 HashedWheelTimer.md)</p>
<p>这个也可以看看</p>
<p>HashedWheelTimer 的构造函数清晰地列举出了几个核心属性：</p>
<ul>
<li><strong>threadFactory</strong>，线程池，但是只创建了一个线程；</li>
<li><strong>tickDuration</strong>，时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot；</li>
<li><strong>unit</strong>，表示 tickDuration 的时间单位；</li>
<li><strong>ticksPerWheel</strong>，时间轮上一共有多少个 slot，默认 512 个。分配的 slot 越多，占用的内存空间就越大；</li>
<li><strong>leakDetection</strong>，是否开启内存泄漏检测；</li>
<li><strong>maxPendingTimeouts</strong>，最大允许等待任务数。</li>
</ul>
<p>时间轮的创建就是为了创建 HashedWheelBucket 数组，每个 HashedWheelBucket 表示时间轮中一个 slot。从 HashedWheelBucket 的结构定义可以看出，HashedWheelBucket 内部是一个双向链表结构，双向链表的每个节点持有一个 HashedWheelTimeout 对象，HashedWheelTimeout 代表一个定时任务。每个 HashedWheelBucket 都包含双向链表 head 和 tail 两个 HashedWheelTimeout 节点，这样就可以实现不同方向进行链表遍历。</p>
<p><strong>添加任务</strong></p>
<p>newTimeout() 方法主要做了三件事，分别为启动工作线程，创建定时任务，并把任务添加到 Mpsc Queue。HashedWheelTimer 的工作线程采用了懒启动的方式，不需要用户显示调用。这样做的好处是在时间轮中没有任务时，可以避免工作线程空转而造成性能损耗</p>
<p>工作线程的启动之前，会通过 CAS 操作获取工作线程的状态，如果已经启动，则直接跳过。如果没有启动，再次通过 CAS 操作更改工作线程状态，然后启动工作线程。启动的过程是直接调用的 Thread#start() 方法</p>
<p>回到 newTimeout() 的主流程，接下来的逻辑就非常简单了。根据用户传入的任务延迟时间，可以计算出任务的 deadline，然后创建定时任务 HashedWheelTimeout 对象，最终把 HashedWheelTimeout 添加到 Mpsc Queue 中。看到这里，你会不会有个疑问，为什么不是将 HashedWheelTimeout 直接添加到时间轮中呢？而是先添加到 Mpsc Queue？Mpsc Queue 可以理解为多生产者单消费者的线程安全队列，下节课我们会对 Mpsc Queue 详细分析，在这里就不做展开了。可以猜到 HashedWheelTimer 是想借助 Mpsc Queue 保证多线程向时间轮添加任务的线程安全性。****</p>
<p><strong>工作线程 Worker</strong></p>
<p>工作线程 Worker 的核心执行流程是代码中的 do-while 循环，只要 Worker 处于 STARTED 状态，就会执行 do-while 循环，我们把该过程拆分成为以下几个步骤，逐一分析。</p>
<ul>
<li>通过 waitForNextTick() 方法计算出时针到下一次 tick 的时间间隔，然后 sleep 到下一次 tick。</li>
<li>通过位运算获取当前 tick 在 HashedWheelBucket 数组中对应的下标</li>
<li>移除被取消的任务。</li>
<li>从 Mpsc Queue 中取出任务加入对应的 HashedWheelBucket 中。</li>
<li>执行当前 HashedWheelBucket 中的到期任务。</li>
</ul>
<p>懒得写了 ，看文章吧</p>
<h2 id="牛客高启盛-美团二面"><a href="#牛客高启盛-美团二面" class="headerlink" title="牛客高启盛-美团二面"></a>牛客高启盛-美团二面</h2><h3 id="知道哪些比较成熟的RPC框架"><a href="#知道哪些比较成熟的RPC框架" class="headerlink" title="知道哪些比较成熟的RPC框架"></a>知道哪些比较成熟的RPC框架</h3><p>DUBBO,GRPC….</p>
<h3 id="你的RPC和Dubbo对比有哪些区别（优缺点）"><a href="#你的RPC和Dubbo对比有哪些区别（优缺点）" class="headerlink" title="你的RPC和Dubbo对比有哪些区别（优缺点）"></a>你的RPC和Dubbo对比有哪些区别（优缺点）</h3><ol>
<li><strong>服务治理：</strong> Dubbo提供了完整的服务治理功能，包括负载均衡、容错机制、服务注册与发现等。这使得在大型分布式系统中更容易管理和维护服务。</li>
<li><strong>丰富的特性：</strong> Dubbo提供了更丰富的特性，例如可插拔的协议、注册中心、集群等。这使得Dubbo适用于更复杂的应用场景。</li>
<li><strong>生态系统：</strong> Dubbo在阿里巴巴内部积累了大量的应用场景，具有较为丰富的生态系统。</li>
</ol>
<h3 id="粘包拆包怎么解决"><a href="#粘包拆包怎么解决" class="headerlink" title="粘包拆包怎么解决"></a>粘包拆包怎么解决</h3><p>就是自己设计了传输协议么</p>
<h3 id="说一说Netty的原理"><a href="#说一说Netty的原理" class="headerlink" title="说一说Netty的原理"></a>说一说Netty的原理</h3><p>还没想好怎么回答这个逆天问题</p>
<h3 id="三种线程模型如何选型？主从多线程模型一定更快吗"><a href="#三种线程模型如何选型？主从多线程模型一定更快吗" class="headerlink" title="三种线程模型如何选型？主从多线程模型一定更快吗"></a>三种线程模型如何选型？主从多线程模型一定更快吗</h3><ul>
<li><p>单Reacotor单线程模型用的很少，基本没啥用，因为不能充分利用多核资源，当处理读写任务线程(单线程)负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差。再加上可靠性问题，一旦Reactor线程意外中断会导致整个通信模块不可用，无法接收和处理外部消息，造成节点故障。</p>
</li>
<li><p>单Reactor多线程模型，区别在于处理器部分使用了多线程，可以满足绝大多数的场景，除了一些个别的特殊场景：比如一个NIO线程负责处理客户所有的连接请求，但是如果连接请求中包含认证的需求（安全认证），在百万级别的场景下，就存在性能问题了，因为认证本身就要消耗CPU。</p>
</li>
<li><p>主从多线程模型：接入认证、IP黑白名单过滤、握手等操作的时候，需要主从多线程模型</p>
</li>
</ul>
<p>不一定更快，因为认证、过滤等操作本身也需要消耗cpu</p>
<h3 id="并发量小就不能用多线程模式吗"><a href="#并发量小就不能用多线程模式吗" class="headerlink" title="并发量小就不能用多线程模式吗"></a>并发量小就不能用多线程模式吗</h3><h3 id="两个节点有海量数据传输用哪种线程结构？（把他拆成多线程去传输还是什么，怎么选型？）"><a href="#两个节点有海量数据传输用哪种线程结构？（把他拆成多线程去传输还是什么，怎么选型？）" class="headerlink" title="两个节点有海量数据传输用哪种线程结构？（把他拆成多线程去传输还是什么，怎么选型？）"></a>两个节点有海量数据传输用哪种线程结构？（把他拆成多线程去传输还是什么，怎么选型？）</h3><h2 id="声哥总结的"><a href="#声哥总结的" class="headerlink" title="声哥总结的"></a>声哥总结的</h2><h3 id="为什么用-RPC，不用-HTTP"><a href="#为什么用-RPC，不用-HTTP" class="headerlink" title="为什么用 RPC，不用 HTTP"></a>为什么用 RPC，不用 HTTP</h3><p>RPC 是一种<strong>设计</strong>，就是为了解决<strong>不同服务之间的调用问题</strong>，完整的 RPC 实现一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。</p>
<p>使用 TCP 和使用 HTTP 各有优势：</p>
<p><strong>传输效率</strong>：</p>
<ul>
<li>TCP，通常自定义上层协议，可以让请求报文体积更小 </li>
<li>HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容</li>
</ul>
<p><strong>性能消耗</strong>，主要在于序列化和反序列化的耗时</p>
<ul>
<li>TCP，可以基于各种序列化框架进行，效率比较高 </li>
<li>HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能</li>
</ul>
<p><strong>跨平台</strong>：</p>
<ul>
<li>TCP：通常要求客户端和服务器为统一平台 </li>
<li>HTTP：可以在各种异构系统上运行</li>
</ul>
<p><strong>总结</strong>：<br>  RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p>
<h3 id="调用如何在客户端无感（动态代理）"><a href="#调用如何在客户端无感（动态代理）" class="headerlink" title="调用如何在客户端无感（动态代理）"></a>调用如何在客户端无感（动态代理）</h3><p>项目中使用了JDK动态代理，具体流程被包含在了通过注解自动注册服务的过程当中，对每一个bean检查他是否有@RpcReference注解，如果有说明他是一个消费服务，需要调用远程方法，那么就通过RpcClientProxy创建了一个代理对象 clientProxy，通过反射将clientProxy映射到原来的字段值上，然后会在方法调用时委托给invoke方法，invoke方法负责执行远程调用，而对于客户端来讲，和调用本地方法的外观是一样的。</p>
<h3 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h3><p>静态代理的代理对象和被代理对象在代理之前就已经确定，它们都实现相同的接口或继承相同的抽象类。<strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的</strong></p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>JDK 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用业务方法前调用<code>InvocationHandler</code> 处理。代理类必须实现 <code>InvocationHandler</code> 接口，并且，JDK 动态代理只能代理实现了接口的类</p>
<h3 id="如果想代理没有实现接口的对象"><a href="#如果想代理没有实现接口的对象" class="headerlink" title="如果想代理没有实现接口的对象"></a>如果想代理没有实现接口的对象</h3><p><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>(Code Generation Library)是一个基于<a target="_blank" rel="noopener" href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<h3 id="对象是怎么在网络中传输的"><a href="#对象是怎么在网络中传输的" class="headerlink" title="对象是怎么在网络中传输的"></a>对象是怎么在网络中传输的</h3><p>通过将对象序列化成字节数组，即可将对象发送到网络中。</p>
<p>在 Java 中，想要序列化一个对象，这个对象所属的类必须实现了 <code>Serializable</code> 接口，并且其内部属性必须都是可序列化的。如果有一个属性不是可序列化的，则该属性必须被声明为 <code>transient</code>。</p>
<p>JDK 中提供了 ObjectOutStream 类来对对象进行序列化。</p>
<p>本项目使用了kryo做序列化</p>
<h3 id="你的框架实现了哪几种序列化方式"><a href="#你的框架实现了哪几种序列化方式" class="headerlink" title="你的框架实现了哪几种序列化方式"></a>你的框架实现了哪几种序列化方式</h3><p>本项目实现的基于kryo的序列化</p>
<p>Kryo 是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂</p>
<h3 id="简单介绍一下-Netty"><a href="#简单介绍一下-Netty" class="headerlink" title="简单介绍一下 Netty"></a>简单介绍一下 Netty</h3><p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty 基于 NIO 的，封装了 JDK 的 NIO，让我们使用起来更加方法灵活。</p>
<p>特点和优势：</p>
<ul>
<li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。 </li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。</li>
</ul>
<h3 id="为什么-Netty-性能高"><a href="#为什么-Netty-性能高" class="headerlink" title="为什么 Netty 性能高"></a>为什么 Netty 性能高</h3><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li>
<li>串行化处理读写：避免使用锁带来的性能开销。 </li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h3 id="简单说下-BIO、NIO-和-AIO"><a href="#简单说下-BIO、NIO-和-AIO" class="headerlink" title="简单说下 BIO、NIO 和 AIO"></a>简单说下 BIO、NIO 和 AIO</h3><p>BIO（同步阻塞）：客户端在请求数据的过程中，<strong>保持一个连接</strong>，<strong>不能做其他事情</strong>，线程开销大</p>
<p>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</p>
<p>AIO：一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<h3 id="如何解决-TCP-的粘包拆包问题"><a href="#如何解决-TCP-的粘包拆包问题" class="headerlink" title="如何解决 TCP 的粘包拆包问题"></a>如何解决 TCP 的粘包拆包问题</h3><p>我的项目里是使用了自定义的传输协议解决这个问题，然后xxxxx前面有回答过了</p>
<p>但是Netty也有自己提供了一些解决方式</p>
<p>Netty 自带解决方式：</p>
<ul>
<li>消息定长：FixedLengthFrameDecoder 类</li>
<li>包尾增加特殊字符分割：<ul>
<li>行分隔符类：LineBasedFrameDecoder </li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
</ul>
</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<h3 id="说下-Netty-零拷贝"><a href="#说下-Netty-零拷贝" class="headerlink" title="说下 Netty 零拷贝"></a>说下 Netty 零拷贝</h3><p>[16 IO 加速：与众不同的 Netty 零拷贝技术 (lianglianglee.com)](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty">https://learn.lianglianglee.com/专栏/Netty</a> 核心原理剖析与 RPC 实践-完&#x2F;16  IO 加速：与众不同的 Netty 零拷贝技术.md)</p>
<p>有一说一这个博客无敌啊感觉，全是好文章</p>
<ul>
<li><p><strong>堆外内存：</strong>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p>
</li>
<li><p><strong>CompositeByteBuf</strong>：在 CompositeByteBuf 内部保存着每个 ByteBuf 的引用关系，从逻辑上构成一个整体。CompositeByteBuf 内部维护了一个 Components 数组。在每个 Component 中存放着不同的 ByteBuf，各个 ByteBuf 独立维护自己的读写索引，而 CompositeByteBuf 自身也会单独维护一个读写索引。这样避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p>
</li>
<li><p><strong>ByteBuf.slice 操作</strong>：ByteBuf.slice 是将一个 ByteBuf 对象切分成多个共享同一个底层存储的 ByteBuf 对象。由于底层存储是共享的，所以也避免了新建bytebuf对象所需要的拷贝操作</p>
</li>
<li><p><strong>文件传输 FileRegion</strong>：Netty 使用 FileRegion 实现文件传输的零拷贝，FileRegion 其实就是对 FileChannel 的包装，并没有什么特殊操作，底层使用的是 JDK NIO 中的 FileChannel#transferTo() 方法实现文件传输，所以 FileRegion 是操作系统级别的零拷贝。</p>
</li>
</ul>
<h3 id="简单说下-Netty-中的重要组件"><a href="#简单说下-Netty-中的重要组件" class="headerlink" title="简单说下 Netty 中的重要组件"></a>简单说下 Netty 中的重要组件</h3><ul>
<li><p>Channel：Netty 网络操作抽象类，它包括基本的 I&#x2F;O 操作，如 bind、connect、read、write 等。 </p>
</li>
<li><p>EventLoop：主要是配合 Channel 处理 I&#x2F;O 操作，用来处理连接的生命周期中所发生的事情。 </p>
</li>
<li><p>ChannelFuture：Netty 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。 </p>
</li>
<li><p>ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。 </p>
</li>
<li><p>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</p>
</li>
</ul>
<h3 id="Netty-中责任链模式"><a href="#Netty-中责任链模式" class="headerlink" title="Netty 中责任链模式"></a>Netty 中责任链模式</h3><p>责任链模式为请求创建了一个处理对象的链，发起请求和具体处理请求的过程进行解耦:职责链上的处理者负责处理请求,客户只需要将请求发送到职责链上,无需关心请求的处理细节和请求的传递.</p>
<p>netty 的 pipeline 设计,就采用了责任链设计模式, 底层采用双向链表的数据结构, 将链上的各个处理器(handler)串联起来</p>
<p>客户端每一个请求的到来，netty 都认为，pipeline 中的所有的处理器都有机会处理它，因此，对于入栈的请求，全部从头节点开始往后传播，一直传播到尾节点（来到尾节点的 msg 会被释放掉）。</p>
<p>责任终止机制</p>
<ul>
<li>在pipeline中的任意一个节点，只要我们不手动的往下传播下去，这个事件就会终止传播在当前节点 </li>
<li>对于入站数据，默认会传递到尾节点，进行回收，如果我们不进行下一步传播，事件就会终止在当前节点</li>
</ul>
<h3 id="Netty-是如何保持长连接的（心跳）"><a href="#Netty-是如何保持长连接的（心跳）" class="headerlink" title="Netty 是如何保持长连接的（心跳）"></a>Netty 是如何保持长连接的（心跳）</h3><p>首先 TCP  协议的实现中也提供了 keepalive 报文用来探测对端是否可用。TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。</p>
<p><code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 keepAlive 设置。</p>
<p>虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:</p>
<ol>
<li>它不是 TCP 的标准协议, 并且是默认关闭的.</li>
<li>TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 <strong>两个小时</strong>, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.</li>
<li>TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.</li>
</ol>
<p>Netty 中提供了 <code>IdleStateHandler</code> 类专门用于处理心跳。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">IdleStateHandler</span><span class="token punctuation">(</span><span class="token keyword">long</span> readerIdleTime<span class="token punctuation">,</span> <span class="token keyword">long</span> writerIdleTime<span class="token punctuation">,</span> 
                        <span class="token keyword">long</span> allIdleTime<span class="token punctuation">,</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第三个参数是全能型参数，隔多久检查读写事件；</p>
<p>第四个参数表示当前的时间单位。</p>
<p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p>
<h2 id="牛客-雨鱼羽-zk部分"><a href="#牛客-雨鱼羽-zk部分" class="headerlink" title="牛客-雨鱼羽-zk部分"></a>牛客-雨鱼羽-zk部分</h2><h3 id="为什么用Zookeeper做注册中心？"><a href="#为什么用Zookeeper做注册中心？" class="headerlink" title="为什么用Zookeeper做注册中心？"></a>为什么用Zookeeper做注册中心？</h3><p>就是各种类似的问题，比如什么zk的好处啊，优点啊什么的</p>
<ul>
<li><p>Zookeeper的数据模型很简单，有一系列被称为ZNode的数据节点组成，与传统的磁盘文件系统不同的是，zk将全量数据存储在内存中，可谓是高性能，而且支持集群，可谓高可用，另外支持事件监听。这些特点决定了zk特别适合作为注册中心(数据发布&#x2F;订阅)。</p>
</li>
<li><p>为什么不用redis？：zookeeper临时节点自动宕机自动清除</p>
</li>
<li><p>和nacos的区别：Zookeeper采用CP保证数据的一致性的问题，原理采用(ZAP原子广播协议)，当我们ZK领导者因为某种情况下部分节点出现了故障，会自动重新实现选举新的领导角色，整个选举的过程中为了保证数据一致性的问题，客户端暂时无法使用我们的Zookeeper，那么这以为着整个微服务无法实现通讯。而Nacos从1.0版本选择Ap和CP混合形式实现注册中心，默认情况下采用Ap，CP则采用Raft协议实现保持数据的一致性。<br> 如果选择为Ap模式，注册服务的实例仅支持临时模式，在网络分区的的情况允许注册服务实例<br> 选择CP模式可以支持注册服务的实例为持久模式，在网络分区的产生了抖动情况下不允许注册服务实例。</p>
</li>
</ul>
<h3 id="Zookeeper和Eureka分别是满足CAP中的哪些"><a href="#Zookeeper和Eureka分别是满足CAP中的哪些" class="headerlink" title="Zookeeper和Eureka分别是满足CAP中的哪些"></a>Zookeeper和Eureka分别是满足CAP中的哪些</h3><p>CAP：一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
<p>Zookeeper采用CP保证数据的一致性的问题，原理采用(ZAP原子广播协议)，当我们ZK领导者因为某种情况下部分节点出现了故障，会自动重新实现选举新的领导角色，整个选举的过程中为了保证数据一致性的问题，客户端暂时无法使用我们的Zookeeper，那么这以为着整个微服务无法实现通讯。</p>
<p>Eureka采用AP设计思想实现分布式注册中心，完全去中心化、每个节点都是相等，采用你中有我、我中有你相互注册设计思想， 只要最后有一台Eureka节点存在整个微服务就可以实现通讯。在eureka集群中，如果某个节点发生宕机，eureka不会有类似zookeeper选举的行为,即不会对外停止服务。客户端请求会切换到别的eureka节点，当宕机的服务器重新恢复后会被再次加入集群管理中同步别的eureka server保存的注册信息。</p>
<h3 id="如果让你设计一个服务注册中心，怎么设计"><a href="#如果让你设计一个服务注册中心，怎么设计" class="headerlink" title="如果让你设计一个服务注册中心，怎么设计"></a>如果让你设计一个服务注册中心，怎么设计</h3><p>这个注册中心需要有如下功能：</p>
<p><strong>服务注册接口</strong>：服务提供者通过调用服务注册接口来完成服务注册。</p>
<p><strong>服务注销接口</strong>：服务提供者通过调用服务反注册接口来完成服务注销。</p>
<p><strong>心跳汇报接口</strong>：服务提供者通过调用心跳汇报接口完成节点存活状态上报。</p>
<p><strong>服务订阅接口</strong>：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</p>
<p><strong>服务变更查询接口</strong>：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。</p>
<p><strong>服务查询接口</strong>：查询注册中心当前注册了哪些服务信息。</p>
<p><strong>服务修改接口</strong>：修改注册中心中某一服务的信息。</p>
<h3 id="集群一般有几个节点，为什么"><a href="#集群一般有几个节点，为什么" class="headerlink" title="集群一般有几个节点，为什么"></a>集群一般有几个节点，为什么</h3><p>5个，宕机后选举要大于一半成为leader。</p>
<h3 id="socket过程中发生的系统调用"><a href="#socket过程中发生的系统调用" class="headerlink" title="socket过程中发生的系统调用"></a>socket过程中发生的系统调用</h3><p>服务器：</p>
<p>​		socket();&#x2F;&#x2F;socket要求必须绑定socket；</p>
<p>​       bind();&#x2F;&#x2F;绑定端口和IP，这样我们才知道是那台主机；</p>
<p>​       listen();&#x2F;&#x2F;监听，看有没有请求连接</p>
<p>​       accept();&#x2F;&#x2F;接收请求</p>
<p>​       send()||rev();&#x2F;&#x2F;接收和发送消息</p>
<p>客户端：</p>
<p>​		socket();&#x2F;&#x2F;socket要求必须绑定socket；</p>
<p>​       connect();&#x2F;&#x2F;请求连接</p>
<h3 id="zookeeper服务容灾？"><a href="#zookeeper服务容灾？" class="headerlink" title="zookeeper服务容灾？"></a>zookeeper服务容灾？</h3><p>容灾：在集群若干台故障后，整个集群仍然可以对外提供可用的服务。</p>
<p>解决多数据中心容灾的方案有单机房增加节点、同城多机房、两地三中心(异地容灾)等</p>
<img src="https://static001.geekbang.org/infoq/0e/0ee39def8788e01afb738eac9419cb21.png" alt="img" style="zoom: 67%;">

<p>1）单机房多节点</p>
<p>对于单机房增加节点将其部署在不同的机柜中可以一定程度提高高可用性，避免多个节点同时出现问题</p>
<p><img src="https://static001.geekbang.org/infoq/fd/fd1319e01e2d3739ec2849e2652e2bb0.png" alt="img"></p>
<p>节点选举及事务性请求都需要半数以上成功则算是成功，因此多增加节点对写请求及选举过程的影响都比较大，并且这种方案不能解决整个机房出现故障的容灾问题。</p>
<p>2）同城多机房</p>
<p>单机房做不到容灾，在同城进行多机房的部署，如下图所示：</p>
<p><img src="https://static001.geekbang.org/infoq/e4/e4f53ad6b64b624bc18668b355c3ceae.png" alt="img"></p>
<p>多机房部署要考虑某机房故障情况下，保证有半数以上的 Zookeeper 节点正常工作，如果仅两个机房的情况下无法保证，上例中三机房部署是可以实现任意一个机房故障情况下，满足正常节点上大于半数以上，保证机房容灾。</p>
<h3 id="zookeeper服务节点挂掉之后，怎么删除它"><a href="#zookeeper服务节点挂掉之后，怎么删除它" class="headerlink" title="zookeeper服务节点挂掉之后，怎么删除它"></a>zookeeper服务节点挂掉之后，怎么删除它</h3><p>删除：使用临时节点，会话失效，节点自动清除。</p>
<h3 id="Zookeeper有几种角色"><a href="#Zookeeper有几种角色" class="headerlink" title="Zookeeper有几种角色"></a>Zookeeper有几种角色</h3><p>群首（leader），追随者（follower），观察者（observer），这个在ZAP算法里，好好看看</p>
<h3 id="CAP理论解释下？P是什么？"><a href="#CAP理论解释下？P是什么？" class="headerlink" title="CAP理论解释下？P是什么？"></a>CAP理论解释下？P是什么？</h3><p>一致性（<strong>C</strong>onsistency）多个副本之间的数据一致性</p>
<p>可用性（<strong>A</strong>vailability）在合理规定的时间内，是否能返回一个明确的结果。</p>
<p>分区容错性（<strong>P</strong>artition tolerance）在分区故障下，仍然可以对外提供正常的服务。</p>
<p>一个分布式系统在以上三个特性中：最多满足其中的两个特性</p>
<h3 id="Zookeeper集群节点宕机了怎么发现剔除的"><a href="#Zookeeper集群节点宕机了怎么发现剔除的" class="headerlink" title="Zookeeper集群节点宕机了怎么发现剔除的"></a>Zookeeper集群节点宕机了怎么发现剔除的</h3><p>通过watcher机制</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=zookeeper&spm=1001.2101.3001.7020">zookeeper</a>引入了watcher机制来实现发布&#x2F;订阅功能，能够让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态发生变化时，会通知所有订阅者。当一个集群宕机，其他的集群会通过这个机制得到宕机的消息。</p>
<p>剔除：不知道，貌似是临时节点自动剔除？</p>
<h3 id="服务熔断和服务降级有什么区别"><a href="#服务熔断和服务降级有什么区别" class="headerlink" title="服务熔断和服务降级有什么区别"></a>服务熔断和服务降级有什么区别</h3><p><strong>服务熔断：</strong>如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p>
<p><strong>服务降级：</strong>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p>
<ul>
<li><p>延迟持久化：页面访问照常，但是涉及记录变更，会提示稍晚能看到结果，将数据记录到异步队列或log，服务恢复后执行。</p>
</li>
<li><p>随机拒绝服务：服务接口随机拒绝服务，让用户重试，目前较少有人采用。因为用户体验不佳。</p>
</li>
<li><p>服务接口拒绝服务：页面能访问，但是添加删除操作提示服务器繁忙。页面内容也可在Varnish或CDN内获取。</p>
</li>
<li><p>页面拒绝服务：页面提示由于服务繁忙此服务暂停。跳转到varnish或nginx的一个静态页面。</p>
</li>
</ul>
<h3 id="zk羊群效应？怎么解决（Zookeeper的分布式锁实现方式"><a href="#zk羊群效应？怎么解决（Zookeeper的分布式锁实现方式" class="headerlink" title="zk羊群效应？怎么解决（Zookeeper的分布式锁实现方式"></a>zk羊群效应？怎么解决（Zookeeper的分布式锁实现方式</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Zookeeper&spm=1001.2101.3001.7020">Zookeeper</a>分布式锁场景中的羊群效应指的是所有的客户端都尝试对一个临时节点去加锁，当一个锁被占有的时候，其他的客户端都会监听这个临时节点。一旦锁被释放，Zookeeper反向通知添加监听的客户端，然后大量的客户端都尝试去对同一个临时节点创建锁，最后也只有一个客户端能获得锁，但是大量的请求造成了很大的网络开销，加重了网络的负载，影响Zookeeper的性能。</p>
<p>解决：</p>
<p>首先得了解什么是临时顺序节点：</p>
<ul>
<li>第一，节点的生命周期和client回话绑定，即创建节点的客户端回话一旦失效，那么这个节点就会被删除。（临时性）</li>
<li>第二，每个父节点都会维护子节点创建的先后顺序，自动为子节点分配一个整形数值，以后缀的形式自动追加到节点名称中，作为这个节点最终的节点名称。（顺序性）</li>
</ul>
<p>所以实现分布式锁的一般思路是什么：</p>
<ol>
<li>client调用create()方法创建“&#x2F;zk-locks”节点，注意节点类型是EPHEMERAL_SEQUENTIAL</li>
<li>client调用getChildren(“&#x2F;zk-locks”,watch)来获取所有已经创建的子节点，并同时在这个节点上注册子节点变更通知的Watcher</li>
<li>客户端获取到所有子节点Path后，如果发现自己在步骤1中创建的节点是所有节点中最小的，那么就认为这个客户端获得了锁</li>
<li>如果在步骤3中，发现不是最小的，那么等待，直到下次子节点变更通知的时候，在进行子节点的获取，判断是否获取到锁</li>
<li>释放锁也比较容易，就是删除自己创建的那个节点即可</li>
</ol>
<p>而这种思路因为每个子节点都被注册了watcher，会导致羊群效应</p>
<p>那么如何解决呢？</p>
<p>其实客户端的核心诉求在于判断自己是否是最小的节点，所以说每个节点的创建者其实不用关心所有的节点变更，<strong>它真正关心的应该是比自己序号小的那个节点是否存在</strong></p>
<p>所以修改步骤：</p>
<ol>
<li>client调用create()方法创建“&#x2F;zk-locks”节点，注意节点类型是EPHEMERAL_SEQUENTIAL</li>
<li>client调用getChildren(“&#x2F;zk-locks”,false)来获取所有已经创建的子节点，这里并不注册任何Watcher</li>
<li>客户端获取到所有子节点Path后，如果发现自己在步骤1中创建的节点是所有节点中最小的，那么就认为这个客户端获得了锁</li>
<li>如果在步骤3中，发现不是最小的，<strong>那么找到比自己小的那个节点，然后对其调用exist()方法注册事件监听</strong></li>
<li>之后一旦这个被关注的节点移除，客户端会收到相应的通知，这个时候客户端需要再次调用getChildren(“&#x2F;zk-locks”,false)来确保自己是最小的节点，然后进入步骤3</li>
</ol>
<h3 id="zk的分布式算法zab，如果选举的时候zxid都相同呢"><a href="#zk的分布式算法zab，如果选举的时候zxid都相同呢" class="headerlink" title="zk的分布式算法zab，如果选举的时候zxid都相同呢"></a>zk的分布式算法zab，如果选举的时候zxid都相同呢</h3><p>这个还是在zab里，后面单独总结</p>
<h3 id="Zookeeper-是如何保证一致性的"><a href="#Zookeeper-是如何保证一致性的" class="headerlink" title="Zookeeper 是如何保证一致性的"></a>Zookeeper 是如何保证一致性的</h3><p>这个问题也是在问zab协议</p>
<h3 id="ZooKeeper的作用"><a href="#ZooKeeper的作用" class="headerlink" title="ZooKeeper的作用"></a>ZooKeeper的作用</h3><p>项目答：注册中心。</p>
<p>扩展答：</p>
<ul>
<li><p>数据发布：数据发布&#x2F;订阅（Publish&#x2F;Subscribe）系统，即所谓的配置中心，顾明思义就是发布者将数据发布到zookeeper的一个或一系列的节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。</p>
</li>
<li><p>命名服务：zookeeper的命名服务功能主要是根据指定名字来获取资源或服务的地址，提供者等信息，利用其znode的特点和watcher机制，将其作为动态注册和获取服务信息的配置中心，统一管理服务名称和其对应的服务器列表信息，我们能够近乎实时地感知到后端服务器的状态(上线、下线、宕机)。</p>
</li>
<li><p>全局唯一ID生成器：我们可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。</p>
</li>
<li><p>master选举：主从模式，正常情况下主机提供服务，备机负责监听主机状态，当主机异常时，可以自动切换到备机继续提供服务，这个切换过程中选出下一个主机的过程就是master选举。传统的方法会导致双master情况，而zk利用节点创建的全局唯一性和临时节点的特性，在服务器启动的时候，去zookeeper特定的一个目录下注册一个临时节点(这个节点作为master，谁注册了这个节点谁就是master)，注册的时候，如果发现该节点已经存在，则说明已经有别的服务器注册了(也就是有别的服务器已经抢主成功)，那么当前服务器只能放弃抢主，作为从机存在。同时，抢主失败的当前服务器需要订阅该临时节点的删除事件，以便该节点删除时(也就是注册该节点的服务器宕机了或者网络断了之类的)进行再次抢主操作。从机具体需要去哪里注册服务器列表的临时节点，节点保存什么信息，根据具体的业务不同自行约定。选主的过程，其实就是简单的争抢在zookeeper注册临时节点的操作，谁注册了约定的临时节点，谁就是master。</p>
</li>
<li><p>分布式队列：创建&#x2F;queue作为一个队列，然后每创建一个顺序节点，视为一条消息(节点存储的数据即为消息内容)，生产者每次创建一个新节点，做为消息发送，消费者监听queue的子节点变化（或定时轮询)，每次取最小节点当做消费消息，处理完后，删除该节点。相当于实现了一个FIFO(先进先出)的队列。</p>
</li>
</ul>
<h3 id="服务下线还有没有别的实现方法"><a href="#服务下线还有没有别的实现方法" class="headerlink" title="服务下线还有没有别的实现方法"></a>服务下线还有没有别的实现方法</h3><p>沃特玛怎么知道</p>
<h3 id="如果注册中心服务器宕机怎么保证高可用"><a href="#如果注册中心服务器宕机怎么保证高可用" class="headerlink" title="如果注册中心服务器宕机怎么保证高可用"></a>如果注册中心服务器宕机怎么保证高可用</h3><p>主要考虑***容灾和扩容***两方面提高高可用。容灾刚刚说过了</p>
<h3 id="分布式数据一致性协议都知道哪些"><a href="#分布式数据一致性协议都知道哪些" class="headerlink" title="分布式数据一致性协议都知道哪些"></a>分布式数据一致性协议都知道哪些</h3><p>2PC 3PC Paxos</p>
<h3 id="zookeeper的节点类型"><a href="#zookeeper的节点类型" class="headerlink" title="zookeeper的节点类型?"></a>zookeeper的节点类型?</h3><p>持久，临时，顺序</p>
<h3 id="了解过zookeeper的问题吗"><a href="#了解过zookeeper的问题吗" class="headerlink" title="了解过zookeeper的问题吗"></a>了解过zookeeper的问题吗</h3><ol>
<li>zookeeper master就只能照顾一个机房，其他机房运行的业务模块由于没有master都只能停掉，对网络抖动非常敏感。</li>
<li>选举过程速度很慢且zk选举期间无法对外提供服务。</li>
<li>zk的性能有限:典型的zookeeper的tps大概是一万多，无法覆盖系统内部每天动辄几十亿次的调用。因此每次请求都去zookeeper获取业务系统master信息是不可能的。因此zookeeper的client必须自己缓存业务系统的master地址。</li>
</ol>
<h2 id="牛客-雨鱼羽-序列化协议部分"><a href="#牛客-雨鱼羽-序列化协议部分" class="headerlink" title="牛客-雨鱼羽-序列化协议部分"></a>牛客-雨鱼羽-序列化协议部分</h2><h3 id="各个序列化算法的特性？"><a href="#各个序列化算法的特性？" class="headerlink" title="各个序列化算法的特性？"></a>各个序列化算法的特性？</h3><p><strong>json</strong>：</p>
<ul>
<li><p>JSON 进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销； </p>
</li>
<li><p>JSON 没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以性能不会太好（比如反序列化时先反序列化为String类，要自己通过反射还原）。</p>
</li>
</ul>
<p><strong>Kryo</strong>：这个前面也有总结过</p>
<ul>
<li><p>使用变长的int和long保证这种基本数据类型序列化后尽量小 </p>
</li>
<li><p>需要传入完整类名或者利用 register() 提前将类注册到Kryo上，其类与一个int型的ID相关联，序列中只存放这个ID，因此序列体积就更小 </p>
</li>
<li><p>不是线程安全的，要通过ThreadLocal或者创建Kryo线程池来保证线程安全 </p>
</li>
<li><p>不需要实现Serializable接口 </p>
</li>
<li><p>字段增、减，序列化和反序列化时无法兼容 </p>
</li>
<li><p>必须拥有无参构造函数</p>
</li>
</ul>
<p><strong>Hessian</strong>：</p>
<ul>
<li>使用固定长度存储int和long </li>
<li>将所有类字段信息都放入序列化字节数组中，直接利用字节数组进行反序列化，不需要其他参与，因为存的东西多处理速度就会慢点。 </li>
<li>把复杂对象的所有属性存储在一个Map中进行序列化。所以在父类、子类存在同名成员变量的情况下，Hessian序列化时，先序列化子类，然后序列化父类，因此反序列化结果会导致子类同名成员变量被父类的值覆盖 </li>
<li>需要实现Serializable接口 </li>
<li>兼容字段增、减，序列化和反序列化 </li>
<li>必须拥有无参构造函数 </li>
<li>Java 里面一些常见对象的类型不支持，比如：<ul>
<li>Linked 系列，LinkedHashMap、LinkedHashSet 等； </li>
<li>Locale 类，可以通过扩展 ContextSerializerFactory 类修复； </li>
<li>Byte&#x2F;Short 反序列化的时候变成 Integer。</li>
</ul>
</li>
</ul>
<p><strong>Protobuf</strong>：</p>
<ul>
<li>序列化后体积相比 JSON、Hessian 小很多</li>
<li>序列化反序列化速度很快，不需要通过反射获取类型；</li>
<li>打包生成二进制流</li>
<li>预编译过程不是必须的</li>
</ul>
<h3 id="序列化和反序列化有什么作用"><a href="#序列化和反序列化有什么作用" class="headerlink" title="序列化和反序列化有什么作用"></a>序列化和反序列化有什么作用</h3><p>（1）<strong>实现了数据的持久化</strong>：永久性保存对象，保存对象的字节序列到本地文件或者数据库中；<br>（2）<strong>序列化实现远程通</strong>：通过序列化以字节流的形式使对象在网络中进行传递和接收；<br>（3）通过序列化在进程间传递对象；</p>
<h3 id="Serializable和Externalizable懂吗"><a href="#Serializable和Externalizable懂吗" class="headerlink" title="Serializable和Externalizable懂吗"></a>Serializable和Externalizable懂吗</h3><p>1、Serializable序列化时不会调用默认的构造器，而Externalizable序列化时会调用默认构造器的！</p>
<p>2、Serializable：一个对象想要被序列化，它的类就要实现此接口，这个对象的所有属性都可以被序列化和反序列化来保存、传递。 </p>
<p>​      Externalizable：自定义序列化可以控制序列化的过程和决定哪些属性不被序列化。</p>
<p>3、使用Externalizable时，必须按照写入时的确切顺序读取所有字段状态。否则会产生异常。</p>
<h3 id="serializable关键字的作用（实现原理）"><a href="#serializable关键字的作用（实现原理）" class="headerlink" title="serializable关键字的作用（实现原理）"></a>serializable关键字的作用（实现原理）</h3><p>Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。</p>
<p>因为 Java IO 是一种装饰者模式，因此可以通过 ObjectOutStream 包装 FileOutStream 将数据写入到文件中或者包装 ByteArrayOutStream 将数据写入到内存中。同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象即可。</p>
<p>静态成员变量是不能被序列化,序列化是针对对象属性的，而静态成员变量是属于类的。</p>
<p>然后序列化步骤就是：</p>
<ul>
<li>将对象实例相关的类元数据输出。</li>
<li>递归地输出类的超类描述直到不再有超类。</li>
<li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li>
<li>从上至下递归输出实例的数据</li>
</ul>
<h3 id="序列化传输"><a href="#序列化传输" class="headerlink" title="序列化传输"></a>序列化传输</h3><ul>
<li>进程之间要通过网络传输结构化的数据，需要通过序列化和反序列化来实现结构化数据和二进制数据的双向转换。在选择序列化实现的时候，需要综合考虑数据可读性，实现复杂度，性能和信息密度这四个因素。</li>
<li>大多数情况下，选择一个高性能的通用序列化框架都可以满足要求，在性能可以满足需求的前提下，推荐优先选择 JSON 这种可读性好的序列化方法。</li>
<li>如果说我们需要超高的性能，或者是带宽有限的情况下，可以使用专用的序列化方法，来提升序列化性能，节省传输流量。不过实现起来很复杂，大部分情况下并不划算。</li>
</ul>
<h3 id="为什么不能直接把内存中对象对应的二进制数据直接通过网络发送出去。为什么还需要序列化和反序列化呢"><a href="#为什么不能直接把内存中对象对应的二进制数据直接通过网络发送出去。为什么还需要序列化和反序列化呢" class="headerlink" title="为什么不能直接把内存中对象对应的二进制数据直接通过网络发送出去。为什么还需要序列化和反序列化呢"></a><strong>为什么不能直接把内存中对象对应的二进制数据直接通过网络发送出去。为什么还需要序列化和反序列化呢</strong></h3><p>内存里存的东西，不通用， 不同系统， 不同语言的组织可能都是不一样的， 而且还存在很多引用， 指针，并不是直接数据块。</p>
<p>序列化， 反序列化， 其实是约定一种标准吧， 大家都按这个标准去弄， 就能跨平台 ， 跨语言。</p>
<p>虽然都是二进制的数据，但是序列化的二进制数据是通过一定的协议将数据字段进行拼接。第一个优势是：不同的语言都可以遵循这种协议进行解析，实现了跨语言。第二个优势是：这种数据可以直接持久化到磁盘，从磁盘读取后也可以通过这个协议解析出来。</p>
<h3 id="RPC-不同序列化协议了解吗？优缺点是？各种序列号协议的特点？序列化方式有哪几个，区别是什么，自己写过吗"><a href="#RPC-不同序列化协议了解吗？优缺点是？各种序列号协议的特点？序列化方式有哪几个，区别是什么，自己写过吗" class="headerlink" title="RPC 不同序列化协议了解吗？优缺点是？各种序列号协议的特点？序列化方式有哪几个，区别是什么，自己写过吗"></a>RPC 不同序列化协议了解吗？优缺点是？各种序列号协议的特点？序列化方式有哪几个，区别是什么，自己写过吗</h3><p><img src="1.png"></p>
<h3 id="为什么选KRYO序列化？（面试官提示了压缩-，java-的压缩算法"><a href="#为什么选KRYO序列化？（面试官提示了压缩-，java-的压缩算法" class="headerlink" title="为什么选KRYO序列化？（面试官提示了压缩)，java 的压缩算法"></a>为什么选KRYO序列化？（面试官提示了压缩)，java 的压缩算法</h3><ul>
<li><p>使用变长的int和long保证这种基本数据类型序列化后尽量小 </p>
</li>
<li><p>需要传入完整类名或者利用 register() 提前将类注册到Kryo上，其类与一个int型的ID相关联，序列中只存放这个ID，因此序列体积就更小 </p>
</li>
<li><p>不是线程安全的，要通过ThreadLocal或者创建Kryo线程池来保证线程安全 </p>
</li>
<li><p>不需要实现Serializable接口 </p>
</li>
<li><p>字段增、减，序列化和反序列化时无法兼容 </p>
</li>
<li><p>必须拥有无参构造函数</p>
</li>
</ul>
<h3 id="Kryo原理"><a href="#Kryo原理" class="headerlink" title="Kryo原理"></a>Kryo原理</h3><p>Kryo 通过使用类似于 Java 自带的 ObjectOutputStream 和 ObjectInputStream 的方式来进行对象的序列化和反序列化。但是，Kryo 采用了一些优化策略来提高性能和减小序列化结果的尺寸。</p>
<p>Kryo 的核心实现包括以下几个方面：</p>
<ul>
<li><strong>注册机制</strong>：Kryo 可以预先注册需要序列化的类，以避免在序列化过程中写入完整的类名。这样可以减少序列化结果的尺寸。     </li>
<li><strong>缓存机制</strong>：Kryo 使用缓存来存储已经序列化或反序列化过的对象，以便复用对象的状态和减少内存分配开销。     </li>
<li><strong>压缩算法</strong>：Kryo 支持对序列化结果进行压缩，以进一步减小网络传输的负载。</li>
</ul>
<h3 id="你说到你自定义了一个简单协议，自定义的协议头里包括哪些内容，多少字节，各自的作用是什么"><a href="#你说到你自定义了一个简单协议，自定义的协议头里包括哪些内容，多少字节，各自的作用是什么" class="headerlink" title="你说到你自定义了一个简单协议，自定义的协议头里包括哪些内容，多少字节，各自的作用是什么"></a>你说到你自定义了一个简单协议，自定义的协议头里包括哪些内容，多少字节，各自的作用是什么</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">*</span>   <span class="token number">0</span>     <span class="token number">1</span>     <span class="token number">2</span>     <span class="token number">3</span>     <span class="token number">4</span>        <span class="token number">5</span>     <span class="token number">6</span>     <span class="token number">7</span>     <span class="token number">8</span>         <span class="token number">9</span>          <span class="token number">10</span>      <span class="token number">11</span>     <span class="token number">12</span>  <span class="token number">13</span>  <span class="token number">14</span>   <span class="token number">15</span> <span class="token number">16</span>
<span class="token operator">*</span>   <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">*</span>   <span class="token operator">|</span>   magic   code        <span class="token operator">|</span>version <span class="token operator">|</span> full length         <span class="token operator">|</span> messageType<span class="token operator">|</span> codec<span class="token operator">|</span>compress<span class="token operator">|</span>    <span class="token class-name">RequestId</span>       <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                                                                                       <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                         body                                                          <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                                                                                       <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">|</span>                                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                        <span class="token operator">|</span>
<span class="token operator">*</span>   <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">*</span> <span class="token number">4</span>B  magic code（魔法数）   <span class="token number">1</span>B version（版本）   <span class="token number">4</span>B full length（消息长度）    <span class="token number">1</span>B messageType（消息类型）
<span class="token operator">*</span> <span class="token number">1</span>B compress（压缩类型） <span class="token number">1</span>B codec（序列化类型）    <span class="token number">4</span>B  requestId（请求的<span class="token class-name">Id</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先包含4个字节的魔数，用于筛选消息是否符合自定义协议</p>
<p>然后是1字节的版本号</p>
<p>然后是4字节的消息长度位，用来表示消息长度</p>
<p>然后是1字节的消息类型，表示是请求消息，响应消息还是心跳消息</p>
<p>然后是一字节的序列化类型，表示采用什么序列化协议</p>
<p>然后是一字节的压缩类型，表示使用了什么压缩算法</p>
<p>然后是4字节的请求id，用于判断请求和响应是否对应</p>
<p>最后是请求体，也就是内容</p>
<p>本项目采用了kryo进行序列化，我自定义了编码器和解码器，编码就是将消息先按照协议写入魔数等等，然后再将消息体的内容进行序列化，再压缩，最后存入bytebuf中</p>
<p>解码就是将消息从bytebuf中读取，先按照协议检查魔数等是否对应，如果对应则进行解压缩和反序列化</p>
<h3 id="对象有一个属性是对象引用，怎么序列化"><a href="#对象有一个属性是对象引用，怎么序列化" class="headerlink" title="对象有一个属性是对象引用，怎么序列化"></a>对象有一个属性是对象引用，怎么序列化</h3><p>首先被引用的那个对象也必须是可序列化的</p>
<p>而如果多个对象引用了同一个对象b，有可能导致反序列化后，反序列化出多个b对象</p>
<p>java为了解决这种问题，提供了如下机制：</p>
<p><img src="2.png"></p>
<h3 id="如何实现跨语言的序列化或者RPC框架"><a href="#如何实现跨语言的序列化或者RPC框架" class="headerlink" title="如何实现跨语言的序列化或者RPC框架"></a>如何实现跨语言的序列化或者RPC框架</h3><p>RPC框架要想跨语言，本质是在解决<strong>序列化&#x2F;反序列化</strong>的跨语言问题</p>
<h2 id="牛客-雨余羽-Netty部分"><a href="#牛客-雨余羽-Netty部分" class="headerlink" title="牛客-雨余羽-Netty部分"></a>牛客-雨余羽-Netty部分</h2><h3 id="TCP-的粘包的概念是对的吗"><a href="#TCP-的粘包的概念是对的吗" class="headerlink" title="TCP 的粘包的概念是对的吗"></a>TCP 的粘包的概念是对的吗</h3><p>TCP 是面向字节流的，所以这个概念本身是一个伪概念，本身就是可以粘的。但是这种现象还是要解决的</p>
<h3 id="简述AIO、BIO、NIO的具体使用、区别及原理"><a href="#简述AIO、BIO、NIO的具体使用、区别及原理" class="headerlink" title="简述AIO、BIO、NIO的具体使用、区别及原理"></a>简述AIO、BIO、NIO的具体使用、区别及原理</h3><ul>
<li><p>BIO (Blocking I&#x2F;O): 同步阻塞 I&#x2F;O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
</li>
<li><p>NIO (Non-blocking&#x2F;New I&#x2F;O): NIO 是一种同步非阻塞的 I&#x2F;O 模型，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理。对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p>
</li>
<li><p>AIO (Asynchronous I&#x2F;O): AIO 也就是 NIO 2。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。而AIO中，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>
</li>
</ul>
<h3 id="假设有100个连接，采用NIO的方式要服务端要分配几个线程，采用BIO的方式呢"><a href="#假设有100个连接，采用NIO的方式要服务端要分配几个线程，采用BIO的方式呢" class="headerlink" title="假设有100个连接，采用NIO的方式要服务端要分配几个线程，采用BIO的方式呢"></a>假设有100个连接，采用NIO的方式要服务端要分配几个线程，采用BIO的方式呢</h3><p>1,100</p>
<h3 id="为啥要AIO不用多线程，不是一样可以加速吗"><a href="#为啥要AIO不用多线程，不是一样可以加速吗" class="headerlink" title="为啥要AIO不用多线程，不是一样可以加速吗"></a>为啥要AIO不用多线程，不是一样可以加速吗</h3><p>缺点是线程的创建和切换会带来额外的开销，而且随着连接数的增加，线程数量也会增加，可能导致系统资源不足。</p>
<h3 id="NIO中Channel的作用"><a href="#NIO中Channel的作用" class="headerlink" title="NIO中Channel的作用"></a>NIO中Channel的作用</h3><p>Channel是一个通道，可以通过它读取和写入数据，它就像是水管一样，网络数据通过 Channel 进行读取和写入。通道和流的不同之处在与通道是双向的，流只是在一个方向上移动（一个流必须是 InputStream 或者 OutputStram 的子类），而且通道上可以用于读，写或者同事用于读写。因为 Channel 是全双工的，所以它可以比流更好的映射底层操作系统的 API。</p>
<p>NIO 中通过 Channel 封装了对数据源的操作，通过channel 我们可以操作数据源， 但是又不关心数据源的具体数据结构。这个数据源可能是很多种，比如，可以是文件，也可是网络 socket 。 在大多数应用中，channel 与文件描述符或者 socket 是一一对应的。 channel 在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效的传输数据。</p>
<h3 id="NIO中的重要组件？"><a href="#NIO中的重要组件？" class="headerlink" title="NIO中的重要组件？"></a>NIO中的重要组件？</h3><p>Java NIO上有三个重要组件： <code>Channel</code>（通道），Buffer（缓冲区），Selector（选择器）。</p>
<ul>
<li>Channel</li>
</ul>
<p>在IO中，java的IO操作通过输入流（Input Stream）和输出流（Output Stream）进行输入和输出。JavaNIO中，Channel相当于输入流和输出流的结合体。既可以从Channel（通道）中读取，也可以向Channel（通道）写入。</p>
<ul>
<li>Buffer</li>
</ul>
<p>对Channel（通道）的读取操作，就是把数据从通道读取到缓冲区；</p>
<p>对Channel（通道）的写入操作，就是将数据从缓冲区写入通道中；</p>
<ul>
<li>Selector</li>
</ul>
<p>Selector对应“IO多路复用”模型中的select。它是一个IO事件的查询器，通过选择器，一个线程可以查询多个通道的IO事件的就绪状态。</p>
<h3 id="为什么选用Netty来做通信框架？还知道其他网络通信框架"><a href="#为什么选用Netty来做通信框架？还知道其他网络通信框架" class="headerlink" title="为什么选用Netty来做通信框架？还知道其他网络通信框架"></a>为什么选用Netty来做通信框架？还知道其他网络通信框架</h3><p>这个问题相当于是问：netty有哪些优点：</p>
<ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li>
<li>简单而强大的线程模型。</li>
<li>自带编解码器解决 TCP 粘包&#x2F;拆包问题。</li>
<li>自带各种协议栈。</li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li>
<li>安全性不错，有完整的 SSL&#x2F;TLS 以及 StartTLS 支持。</li>
<li>社区活跃、</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如我们经常接触的 Dubbo、RocketMQ 等等。</li>
</ul>
<p><strong>Apache MINA</strong></p>
<p><strong>Node.js</strong></p>
<p><strong>gRPC</strong></p>
<h3 id="为什么Netty快，性能高xxx"><a href="#为什么Netty快，性能高xxx" class="headerlink" title="为什么Netty快，性能高xxx"></a>为什么Netty快，性能高xxx</h3><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li>
<li>串行化处理读写：避免使用锁带来的性能开销。 </li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h3 id="netty-bytebuf工作原理，和NIO里buffer区别"><a href="#netty-bytebuf工作原理，和NIO里buffer区别" class="headerlink" title="netty bytebuf工作原理，和NIO里buffer区别"></a>netty bytebuf工作原理，和NIO里buffer区别</h3><p>那就先回答他的零拷贝那些东西吧，然后区别呢</p>
<p>就是：</p>
<ol>
<li><strong>池化：</strong> Netty 的 <code>ByteBuf</code> 支持池化，而 Java NIO 的 <code>ByteBuffer</code> 不支持。池化可以提高内存使用效率，减轻 GC 压力。</li>
<li><strong>可扩容：</strong> <code>ByteBuf</code> 可以自动扩容，而 <code>ByteBuffer</code> 在创建时需要指定容量，无法自动扩容。</li>
<li><strong>读写索引分离：</strong> <code>ByteBuf</code> 允许读写索引分离移动，提供更灵活的读写操作，而 <code>ByteBuffer</code> 的读写索引总是一起移动。</li>
<li><strong>引用计数：</strong> <code>ByteBuf</code> 支持引用计数，可以更好地管理内存，防止内存泄漏。</li>
</ol>
<h3 id="Netty的使用场景"><a href="#Netty的使用场景" class="headerlink" title="Netty的使用场景"></a>Netty的使用场景</h3><ul>
<li><p>作为 RPC 框架的网络通信工具 ： 我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务节点的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！</p>
</li>
<li><p>实现一个自己的 HTTP 服务器 ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。</p>
</li>
<li><p>实现一个即时通讯系统 ： 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。</p>
</li>
<li><p>实现消息推送系统 ：市面上有很多消息推送系统都是基于 Netty 来做的。</p>
</li>
</ul>
<h3 id="RPC过程网络上发生了什么"><a href="#RPC过程网络上发生了什么" class="headerlink" title="RPC过程网络上发生了什么"></a>RPC过程网络上发生了什么</h3><p>不知道</p>
<h3 id="RPC多个请求是在一个连接完成的吗"><a href="#RPC多个请求是在一个连接完成的吗" class="headerlink" title="RPC多个请求是在一个连接完成的吗"></a>RPC多个请求是在一个连接完成的吗</h3><ol>
<li><strong>短连接模型：</strong> 每次RPC请求都会建立一个新的连接，请求处理完成后连接立即关闭。这样的模型类似于HTTP的短连接模型，每个请求都是相互独立的。在这种模型下，多个请求可能会通过不同的连接完成。</li>
<li><strong>长连接模型：</strong> 通过一个长期存在的连接（通常是TCP连接），多个RPC请求可以在同一个连接上复用。连接在一段时间内保持打开状态，多个请求和响应可以通过这个连接来回传递。这样可以减少连接的建立和关闭开销，提高效率。</li>
</ol>
<h3 id="Netty服务调用如何变成同步的"><a href="#Netty服务调用如何变成同步的" class="headerlink" title="Netty服务调用如何变成同步的"></a>Netty服务调用如何变成同步的</h3><p>它们可以用于异步操作的同步化。你可以通过调用<code>sync()</code>方法来等待一个Future完成，或者通过<code>await()</code>方法等待Promise完成。这种方式在Netty的异步模型中是比较常见的。</p>
<h3 id="Netty异步编程怎么做的"><a href="#Netty异步编程怎么做的" class="headerlink" title="Netty异步编程怎么做的"></a>Netty异步编程怎么做的</h3><p><code>Future</code>表示一个异步操作的结果，而<code>Promise</code>是<code>Future</code>的扩展，它允许设置异步操作的结果。通过<code>Future</code>和<code>Promise</code>，你可以实现异步操作的监听和等待。 在Netty中，你可以通过回调机制注册监听器来处理异步操作的结果。例如，在写数据完成后触发回调，或者在接收到新连接时触发回调。</p>
<h3 id="基于Netty实现通信，使用了哪些TCP优化参数"><a href="#基于Netty实现通信，使用了哪些TCP优化参数" class="headerlink" title="基于Netty实现通信，使用了哪些TCP优化参数"></a>基于Netty实现通信，使用了哪些TCP优化参数</h3><p><strong>TCP_NODELAY：</strong> 关闭Nagle算法，减少延迟。Nagle算法通过将小的数据包合并成一个大的数据包来提高网络的利用率，但是对于低延迟要求的应用，可以通过禁用Nagle算法来减小延迟。</p>
<p><strong>SO_KEEPALIVE：</strong> 开启TCP keepalive机制，用于检测连接是否还存活。通过定期发送TCP的Keepalive探测包，可以及时发现连接断开，避免因连接长时间不活跃而被中断。</p>
<p><strong>SO_BACKLOG：</strong> 设置TCP连接的等待队列大小。当服务器处理连接请求的速度不够快时，连接请求将被放入等待队列，这个参数就是设置等待队列的大小。</p>
<p><strong>TCP_FASTOPEN：</strong> 开启TCP Fast Open特性，允许在三次握手的同时发送数据。可以减少连接建立的延迟。</p>
<h3 id="Netty中的select过程"><a href="#Netty中的select过程" class="headerlink" title="Netty中的select过程"></a>Netty中的select过程</h3><p><strong>Selector 的创建：</strong> 在 Netty 中，创建 Selector 是通过 <code>SelectorProvider</code> 提供的工厂方法实现的。</p>
<p><strong>Channel 的注册：</strong> 在 Netty 中，Channel（比如 <code>ServerSocketChannel</code>、<code>SocketChannel</code>）被注册到 Selector 上，以便 Selector 监听这些 Channel 上的事件。</p>
<p><strong>事件监听：</strong> Selector 通过 <code>select</code> 方法监听已注册的 Channel 上发生的事件。<code>select</code> 方法是一个阻塞方法，直到有感兴趣的事件发生或超时。</p>
<p><strong>处理事件：</strong> 一旦 <code>select</code> 方法返回，就可以通过 <code>selectedKeys</code> 获取已经就绪的 SelectionKey 集合，然后可以迭代这个集合，处理每个就绪的 Channel。</p>
<p><strong>取消注册：</strong> 在处理完一个事件后，通常会取消对应 Channel 的注册，以防止该 Channel 的事件再次被触发。</p>
<h3 id="怎么实现保持长连接的"><a href="#怎么实现保持长连接的" class="headerlink" title="怎么实现保持长连接的"></a>怎么实现保持长连接的</h3><p>TCP_KEEP_ALIVE</p>
<h3 id="多少个线程，为什么这么设置？"><a href="#多少个线程，为什么这么设置？" class="headerlink" title="多少个线程，为什么这么设置？"></a>多少个线程，为什么这么设置？</h3><p>netty自带的，默认CPU核心数*2</p>
<p>为什么：</p>
<ul>
<li>在 I&#x2F;O 密集型任务中，可能存在部分线程阻塞在 I&#x2F;O 操作上，等待数据的读取或写入。为了充分利用 CPU，可以增加 workerGroup 的线程数。</li>
<li>对于 CPU 密集型任务，如果线程数多于 CPU 核心数，由于线程切换的开销，可能会导致性能下降。因此，一般不会将线程数设置得太多。</li>
</ul>
<h2 id="牛客-雨余羽-负载均衡"><a href="#牛客-雨余羽-负载均衡" class="headerlink" title="牛客-雨余羽-负载均衡"></a>牛客-雨余羽-负载均衡</h2><h3 id="项目中负载均衡算法用到那些"><a href="#项目中负载均衡算法用到那些" class="headerlink" title="项目中负载均衡算法用到那些"></a>项目中负载均衡算法用到那些</h3><p>随机和一致性哈希</p>
<h3 id="解释一下什么是负载均衡"><a href="#解释一下什么是负载均衡" class="headerlink" title="解释一下什么是负载均衡"></a>解释一下什么是负载均衡</h3><p>指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行</p>
<p>之后结合算法回答</p>
<h3 id="负载均衡有哪些策略"><a href="#负载均衡有哪些策略" class="headerlink" title="负载均衡有哪些策略"></a>负载均衡有哪些策略</h3><ol>
<li>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的<strong>默认</strong>负载均衡策略(Dubbo 中的随机负载是按照权重设置随机概率)。</li>
</ol>
<p>问题：存在慢的提供者请求的问题，比如：第二胎机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上</p>
<ol start="2">
<li><p>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个，其实是平滑加权算法，也就是说轮询到的节点执行后要减去全部权重</p>
</li>
<li><p>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差（针对特定提供者：请求发送数 - 响应返回数）。</p>
</li>
</ol>
<p>好处：使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。</p>
<ol start="4">
<li>ConsistentHashLoadBalance:一致性哈希负载均衡。一致性hash：添加删除机器前后映射关系一致，当然，不是严格一致。实现的关键是环形Hash空间。将数据和机器都hash到环上，数据映射到顺时针离自己最近的机器中。</li>
</ol>
<p>好处：当某一台提供者挂时，原本该发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动</p>
<h3 id="RPC调用中使用随机算法和轮转算法做负载均衡的优缺点"><a href="#RPC调用中使用随机算法和轮转算法做负载均衡的优缺点" class="headerlink" title="RPC调用中使用随机算法和轮转算法做负载均衡的优缺点"></a>RPC调用中使用随机算法和轮转算法做负载均衡的优缺点</h3><p>优点：实现简单，水平扩展方便</p>
<p>缺点：因为相同的请求会被落到不同的机器上，浪费内存啊，内存有限，Cache会被淘汰，频繁淘汰，当然使得命中率低下啊。</p>
<h3 id="dubbo中一致性哈希算法的实现（你的项目中"><a href="#dubbo中一致性哈希算法的实现（你的项目中" class="headerlink" title="dubbo中一致性哈希算法的实现（你的项目中"></a>dubbo中一致性哈希算法的实现（你的项目中</h3><p>我的 项目的一致性哈希算法是参考了dubbo的实现</p>
<p>dubbo的实现流程是这样的，其实主要就是解决一个映射和选择的问题</p>
<p><strong>ConsistentHashLoadBalance类：</strong></p>
<ul>
<li><code>ConsistentHashLoadBalance</code>类是Dubbo中一致性哈希负载均衡算法的入口。</li>
<li>通过调用<code>doSelect</code>方法实现结点的选择。在<code>doSelect</code>方法中，根据调用的方法名和调用列表的hashCode，获取或创建了<code>ConsistentHashSelector</code>对象。</li>
<li><code>ConsistentHashSelector</code>对象负责具体的结点选择。</li>
</ul>
<p><strong>ConsistentHashSelector类：</strong></p>
<ul>
<li><code>ConsistentHashSelector</code>类内部维护了一个<code>TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers</code>，其中<code>Long</code>表示虚拟结点的哈希值，<code>Invoker&lt;T&gt;</code>表示服务提供者。</li>
<li>在构造函数中，通过MD5算法为每个服务提供者生成一定数量（<code>replicaNumber</code>）的虚拟结点，并将它们放入<code>virtualInvokers</code>中。这些虚拟结点分布在哈希环上。</li>
<li>在<code>select</code>方法中，根据调用参数生成key，key默认是invoker的第一个参数，再通过MD5算法生成哈希值。然后调用<code>sekectForKey</code>方法选择最终的服务提供者。</li>
</ul>
<p><strong>sekectForKey方法：</strong></p>
<ul>
<li><code>sekectForKey</code>方法负责根据哈希值在哈希环上选择服务提供者。</li>
<li>如果哈希值直接匹配到某个虚拟结点的key，则直接返回对应的服务提供者。</li>
<li>如果没有直接匹配，找到一个最小上界的key所对应的结点。这通过<code>SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</code> 实现，即找到哈希环上大于等于当前哈希值的部分。</li>
<li>如果<code>tailMap</code>为空，说明当前哈希值位于环的末尾，需要选择环的起始处，即<code>virtualInvokers</code>的第一个结点。</li>
</ul>
<h3 id="Dubbo为什么推荐基于随机的负载均衡"><a href="#Dubbo为什么推荐基于随机的负载均衡" class="headerlink" title="Dubbo为什么推荐基于随机的负载均衡"></a>Dubbo为什么推荐基于随机的负载均衡</h3><p>1.实现简单，水平扩展方便</p>
<p>2.在一个截面上碰撞的概率高，但调用越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重</p>
<h3 id="负载均衡的作用"><a href="#负载均衡的作用" class="headerlink" title="负载均衡的作用"></a>负载均衡的作用</h3><p>（1）根据集群中每个节点的负载情况将用户请求转发到合适的节点上, 以避免单点压力过大的问题</p>
<p>（2）负载均衡可实现集群高可用及伸缩性</p>
<p>​        高可用：某个节点故障时，负载均衡器会将用户请求转发到其他节点,从而保证所有服务持续可用.</p>
<p>​        伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</p>
<h3 id="如何设计负载均衡器"><a href="#如何设计负载均衡器" class="headerlink" title="如何设计负载均衡器"></a>如何设计负载均衡器</h3><p>负载均衡器工作原理有两大方法：</p>
<ol>
<li>接收客户端请求，将请求转发给集群中的各台服务器处理，服务器将处理结果返回给负载均衡器，负载均衡器将处理结果转发给相应的客户端。</li>
<li>接收客户端请求，将请求转发给集群中的各台服务器处理，服务器将处理结果直接返回给相应的客户端。</li>
</ol>
<h3 id="负载均衡如何保证健壮性"><a href="#负载均衡如何保证健壮性" class="headerlink" title="负载均衡如何保证健壮性"></a>负载均衡如何保证健壮性</h3><p>心跳检测</p>
<h2 id="牛客-雨余羽-HTTP和RPC"><a href="#牛客-雨余羽-HTTP和RPC" class="headerlink" title="牛客-雨余羽-HTTP和RPC"></a>牛客-雨余羽-HTTP和RPC</h2><h3 id="RPC-有没有可能会用-HTTP-协议"><a href="#RPC-有没有可能会用-HTTP-协议" class="headerlink" title="RPC 有没有可能会用 HTTP 协议"></a>RPC 有没有可能会用 HTTP 协议</h3><p>可能，比如grpc</p>
<h3 id="RPC-和-HTTP的对比？为什么要用-RPC"><a href="#RPC-和-HTTP的对比？为什么要用-RPC" class="headerlink" title="RPC 和 HTTP的对比？为什么要用 RPC"></a>RPC 和 HTTP的对比？为什么要用 RPC</h3><ol>
<li>传输协议：</li>
</ol>
<p>　　RPC：基于HTTP协议，TCP协议</p>
<p>　　HTTP：基于HTTP协议</p>
<ol start="2">
<li>传输效率：</li>
</ol>
<p>　　RPC：(1)使用自定义的TCP协议，请求报文体积更小，</p>
<p>​                   (2)使用HTTP2协议，也可以很好的减小报文体积，提高传输效率</p>
<p>　　HTTP：(1)基于http1.1的协议，请求中会包含很多无用的内容，</p>
<p>​                     (2)基于HTTP2.0，那么简单的封装下可以作为一个RPC来使用，这时标准的RPC框架更多的是服务治理。</p>
<ol start="3">
<li>性能消耗：</li>
</ol>
<p>　　RPC：可以基于thrift实现高效的二进制传输</p>
<p>　　HTTP：大部分是基于JSON实现的，字节大小和序列化耗时都比thrift要更消耗性能</p>
<ol start="4">
<li>负载均衡：</li>
</ol>
<p>　　RPC：基本自带了负载均衡策略</p>
<p>　　HTTP：需要配置Nginx、HAProxy配置</p>
<ol start="5">
<li>服务治理：（下游服务新增，重启，下线时如何不影响上游调用者）</li>
</ol>
<p>　　RPC：能做到自动通知，不影响上游</p>
<p>　　HTTP：需要事先通知，如修改NGINX配置。</p>
<h3 id="RPC-传输速度比-HTTP-更快吗"><a href="#RPC-传输速度比-HTTP-更快吗" class="headerlink" title="RPC 传输速度比 HTTP 更快吗"></a>RPC 传输速度比 HTTP 更快吗</h3><p>不一定，但一般会快。取决于序列化协议和传输协议，</p>
<p>比如二进制编码肯定比 JSON 节省体积，自定义 tcp 协议&#x2F;HTTP2.0 比 tcp&#x2F;HTTP1.1 要快</p>
<h3 id="用的TCP还是HTTP2传输的"><a href="#用的TCP还是HTTP2传输的" class="headerlink" title="用的TCP还是HTTP2传输的"></a>用的TCP还是HTTP2传输的</h3><p>自己项目、DUBBO：TCP</p>
<p>grpc：http2.0</p>
<h3 id="为什么spring-cloud用的是http"><a href="#为什么spring-cloud用的是http" class="headerlink" title="为什么spring cloud用的是http"></a>为什么spring cloud用的是http</h3><p>HTTP Restful本身轻量，易用，适用性强，可以很容易的跨语言，跨平台，或者与已有系统交互，</p>
<p>目前很多大型项目多语言共存，http是最通用的协议，可以很好地解决跨语言跨平台兼容性</p>
<h3 id="RPC-是用的时候连一次，还是连一次后就长连接"><a href="#RPC-是用的时候连一次，还是连一次后就长连接" class="headerlink" title="RPC 是用的时候连一次，还是连一次后就长连接"></a>RPC 是用的时候连一次，还是连一次后就长连接</h3><p>自己的RPC是长连接（<a target="_blank" rel="noopener" href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https://www.nowcoder.com/jump/super-jump/word?word=Netty">Netty</a> 中提供了 <code>IdleStateHandler</code> 类专门用于处理心跳，所以是长连接</p>
<p> 没有这个，默认一般是短连接）</p>
<p>（这个被问过好几次，我猜是长连接，有大佬知道吗）</p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/rpc/">
                                    <span class="chip bg-color">rpc</span>
                                </a>
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/15/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="算法专题之动态规划">
                        
                        <span class="card-title">算法专题之动态规划</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/12/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="算法之回溯专题">
                        
                        <span class="card-title">算法之回溯专题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">G</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/GuSmallwhite" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>















    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
